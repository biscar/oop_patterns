# OOP Patterns


## Creational

### _Abstract Factory_
* Предоставляет интерфейс для создания семейств взаимосвязанных или взаи
  мозависимых объектов, не специфицируя их конкретных классов.
* ![screenshot of sample](./images/abstract_factory.png)
* система не должна зависеть от того, как создаются, компонуются и пред
ставляются входящие в нее объекты;
* входящие в семейство взаимосвязанные объекты должны использоваться
вместе и вам необходимо обеспечить выполнение этого ограничения;
* система должна конфигурироваться одним из семейств составляющих ее
объектов;
* вы хотите предоставить библиотеку объектов, раскрывая только их интер
фейсы, но не реализацию.

### _Builder_
* Отделяет конструирование сложного объекта от его представления, так что
  в результате одного и того же процесса конструирования могут получаться раз
  ные представления.
*  ![screenshot of sample](./images/builder.png)
* Алгоритм создания сложного объекта не должен зависеть от того, из каких
  частей состоит объект и как они стыкуются между собой; 
* процесс конструирования должен обеспечивать различные представления
  конструируемого объекта.  
### _Factory Method_
* Определяет интерфейс для создания объекта, но оставляет подклассам реше
  ние о том, какой класс инстанцировать. Фабричный метод позволяет классу де
  легировать инстанцирование подклассам.
* ![screenshot of sample](./images/factory_methods.png) 
* классу заранее неизвестно, объекты каких классов ему нужно создавать;
* класс спроектирован так, чтобы объекты, которые он создает, специфици
  ровались подклассами;
* класс делегирует свои обязанности одному из нескольких вспомогательных
 подклассов, и вы планируете локализовать знание о том, какой класс при
 нимает эти обязанности на себя.
### _Prototype_
* Задает виды создаваемых объектов с помощью экземплярапрототипа и созда
  ет новые объекты путем копирования этого прототипа.
  Используйте паттерн прототип, когда система не должна зависеть от того, как
  в ней создаются, компонуются и представляются продукты:
* ![screenshot of sample](./images/prototype.png) 
* инстанцируемые классы определяются во время выполнения, например
  с помощью динамической загрузки;
* для того чтобы избежать построения иерархий классов или фабрик, парал
  лельных иерархии классов продуктов;
* экземпляры класса могут находиться в одном из не очень большого числа
 различных состояний. Может оказаться удобнее установить соответствую
 щее число прототипов и клонировать их, а не инстанцировать каждый раз
 класс вручную в подходящем состоянии.   
### _Singleton_
* Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему
глобальную точку доступа.
* ![screenshot of sample](./images/singleton.png) 
*  должен быть ровно один экземпляр некоторого класса, легко доступный
всем клиентам;
* единственный экземпляр должен расширяться путем порождения подклас
сов, и клиентам нужно иметь возможность работать с расширенным экземп
ляром без модификации своего кода.
##  **Structural:**
 
### _Adapter_
* Преобразует интерфейс одного класса в интерфейс другого, который ожида
  ют клиенты. Адаптер обеспечивает совместную работу классов с несовместимы
  ми интерфейсами, которая без него была бы невозможна.
* ![screenshot of sample](./images/adapter.png)   
* хотите использовать существующий класс, но его интерфейс не соответству
  ет вашим потребностям;
* собираетесь создать повторно используемый класс, который должен взаимо
  действовать с заранее неизвестными или не связанными с ним классами,
  имеющими несовместимые интерфейсы;
* (только для адаптера объектов!) нужно использовать несколько существу
  ющих подклассов, но непрактично адаптировать их интерфейсы путем по
  рождения новых подклассов от каждого. В этом случае адаптер объектов
  может приспосабливать интерфейс их общего родительского класса.  
     
### _Bridge_
* Отделить абстракцию от ее реализации так, чтобы то и другое можно было
  изменять независимо.
* ![screenshot of sample](./images/bridge.png)
* хотите избежать постоянной привязки абстракции к реализации. Так, на
  пример, бывает, когда реализацию необходимо выбирать во время выполне
  ния программы;
* и абстракции, и реализации должны расширяться новыми подклассами.
  В таком случае паттерн мост позволяет комбинировать разные абстрак
  ции и реализации и изменять их независимо;
* изменения в реализации абстракции не должны сказываться на клиентах,
  то есть клиентский код не должен перекомпилироваться;

### _Composite_
* Компонует объекты в древовидные структуры для представления иерархий
частьцелое. Позволяет клиентам единообразно трактовать индивидуальные и со
ставные объекты.
* ![screenshot of sample](./images/composite.png)
* нужно представить иерархию объектов вида частьцелое;
* хотите, чтобы клиенты единообразно трактовали составные и индивидуаль
  ные объекты.
          
  