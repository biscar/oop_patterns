# OOP Patterns


## Creational

### _Abstract Factory_
* Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.
* ![screenshot of sample](./images/abstract_factory.png)
* система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты;
* входящие в семейство взаимосвязанные объекты должны использоваться вместе и вам необходимо обеспечить выполнение этого ограничения;
* система должна конфигурироваться одним из семейств составляющих ее
объектов;
* вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.

### _Builder_
* Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса
 конструирования могут получаться разные представления.
*  ![screenshot of sample](./images/builder.png)
* Алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой; 
* процесс конструирования должен обеспечивать различные представления
  конструируемого объекта.  
### _Factory Method_
* Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.
 Фабричный метод позволяет классу делегировать инстанцирование подклассам.
* ![screenshot of sample](./images/factory_methods.png) 
* классу заранее неизвестно, объекты каких классов ему нужно создавать;
* класс спроектирован так, чтобы объекты, которые он создает, специфицировались подклассами;
* класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и вы планируете локализовать 
знание о том, какой класс принимает эти обязанности на себя.
### _Prototype_
* Задает виды создаваемых объектов с помощью экземпляра прототипа и создает новые объекты путем копирования этого прототипа.
  Используйте паттерн прототип, когда система не должна зависеть от того, как
  в ней создаются, компонуются и представляются продукты:
* ![screenshot of sample](./images/prototype.png) 
* инстанцируемые классы определяются во время выполнения, например с помощью динамической загрузки;
* для того чтобы избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;
* экземпляры класса могут находиться в одном из не очень большого числаразличных состояний.
 Может оказаться удобнее установить соответствующее число прототипов и клонировать их, а не инстанцировать каждый раз
 класс вручную в подходящем состоянии.   
### _Singleton_
* Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
* ![screenshot of sample](./images/singleton.png) 
*  должен быть ровно один экземпляр некоторого класса, легко доступный всем клиентам;
* единственный экземпляр должен расширяться путем порождения подклассов, и клиентам нужно иметь возможность работать
 с расширенным экземпляром без модификации своего кода.
##  **Structural:**
 
### _Adapter_
* Преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты.
 Адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая без него была бы невозможна.
* ![screenshot of sample](./images/adapter.png)   
* хотите использовать существующий класс, но его интерфейс не соответствует вашим потребностям;
* собираетесь создать повторно используемый класс, который должен взаимодействовать с заранее неизвестными или не связанными с ним классами,
  имеющими несовместимые интерфейсы;
* (только для адаптера объектов!) нужно использовать несколько существующих подклассов, но непрактично адаптировать их интерфейсы путем 
порождения новых подклассов от каждого. В этом случае адаптер объектов может приспосабливать интерфейс их общего родительского класса.  
     
### _Bridge_
* Отделить абстракцию от ее реализации так, чтобы то и другое можно было
  изменять независимо.
* ![screenshot of sample](./images/bridge.png)
* хотите избежать постоянной привязки абстракции к реализации. Так, например, бывает, когда реализацию необходимо 
выбирать во время выполнения программы;
* и абстракции, и реализации должны расширяться новыми подклассами.В таком случае паттерн мост позволяет комбинировать
 разные абстракции и реализации и изменять их независимо;
* изменения в реализации абстракции не должны сказываться на клиентах, то есть клиентский код не должен перекомпилироваться;

### _Composite_
* Компонует объекты в древовидные структуры для представления иерархий
часть целое. Позволяет клиентам единообразно трактовать индивидуальные и составные объекты.
* ![screenshot of sample](./images/composite.png)
* нужно представить иерархию объектов вида часть целое;
* хотите, чтобы клиенты единообразно трактовали составные и индивидуальные объекты.

### _Decorator_

* Динамически добавляет объекту новые обязанности. Является гибкой альтернативой порождению подклассов с целью расширения функциональности.
* ![screenshot of sample](./images/decorator.png)
* для динамического, прозрачного для клиентов добавления обязанностей объектам;
* для реализации обязанностей, которые могут быть сняты с объекта;
* когда расширение путем порождения подклассов по какимто причинам неудобно или невозможно.
  Иногда приходится реализовывать много независимых расширений, так что порождение подклассов для поддержки всех возможных 
  комбинаций приведет к комбинаторному росту их числа. В других случаях определение класса может быть скрыто или почему
  либо еще недоступно, так что породить от него подкласс нельзя.          
  